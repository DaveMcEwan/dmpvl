diff --git a/piton/design/rtl/system.v b/piton/design/rtl/system.v
index 2e5244d..2f9d304 100644
--- a/piton/design/rtl/system.v
+++ b/piton/design/rtl/system.v
@@ -142,7 +142,9 @@ module system(
     input sys_clk,
 `endif
 
-    input                                       sys_rst_n,
+    input                                       GPIO_SW_E, // Reset/reboot OPA.
+    input                                       GPIO_SW_C, // Don't boot until sw is pressed.
+    input                                       GPIO_SW_W, // Toggle/select LED source.
 
 `ifndef PITON_FPGA_SYNTH
     input                                       pll_rst_n,
@@ -239,7 +241,7 @@ module system(
     output [`DDR3_DM_WIDTH-1:0]                 ddr_dm,
     `endif // PITONSYS_DDR4
     output [`DDR3_ODT_WIDTH-1:0]                ddr_odt,
-`else //ifndef F1_BOARD 
+`else //ifndef F1_BOARD
     input                                        mc_clk,
     // AXI Write Address Channel Signals
     output wire [`AXI4_ID_WIDTH     -1:0]    m_axi_awid,
@@ -306,8 +308,8 @@ module system(
     output                                      uart_tx,
     input                                       uart_rx,
 `ifdef VCU118_BOARD
-		input                                       uart_cts,
-		output                                      uart_rts,
+    input                                       uart_cts,
+    output                                      uart_rts,
 `endif // VCU118_BOARD
 `endif // endif PITONSYS_UART
 
@@ -391,15 +393,36 @@ module system(
 `endif
 
 `ifdef XUPP3R_BOARD
-    output [3:0]                                leds
-`else 
-    output [7:0]                                leds
+    output [3:0]                                leds,
+`else
+    output [7:0]                                leds,
 `endif
+
+  // VC707 with XM105 in FMC1 with external USB electrical conversion board.
+  // probes: J1 pins in order, overflowing onto J2
+  // pwm: J20 odd numbered pins.
+  // {{{ usb electrical conversion VC707.*
+  output FMC1_HPC_LA29_N, // USB OE     (T30 LVCMOS18 VC707.J17.XX XM105.J16.11)
+  inout  FMC1_HPC_LA29_P, // USB d-     (T29 LVCMOS18 VC707.J17.XX XM105.J16.9)
+  inout  FMC1_HPC_LA28_N, // USB d+     (L30 LVCMOS18 VC707.J17.XX XM105.J16.7)
+  output FMC1_HPC_LA28_P, // usbpu/Vext (L29 LVCMOS18 VC707.J17.XX XM105.J16.5)
+  // }}} usb electrical conversion VC707.*
+  // {{{ result pwm XM105.J20 odd
+  output FMC1_HPC_LA20_P, // (Y29 LVCMOS18 VC707.J17.G21 XM105.J20.1)
+  output FMC1_HPC_LA20_N, // (Y30 LVCMOS18 VC707.J17.G22 XM105.J20.3)
+  output FMC1_HPC_LA21_P, // (N28 LVCMOS18 VC707.J17.H25 XM105.J20.5)
+  output FMC1_HPC_LA21_N, // (N29 LVCMOS18 VC707.J17.H26 XM105.J20.7)
+  output FMC1_HPC_LA22_P, // (R28 LVCMOS18 VC707.J17.G24 XM105.J20.9)
+  output FMC1_HPC_LA22_N, // (P28 LVCMOS18 VC707.J17.G25 XM105.J20.11)
+  output FMC1_HPC_LA23_P, // (P30 LVCMOS18 VC707.J17.D23 XM105.J20.13)
+  output FMC1_HPC_LA23_N  // (N31 LVCMOS18 VC707.J17.D24 XM105.J20.15)
+  // }}} result pwm XM105.J20 odd
 );
 
 ///////////////////////
 // Type declarations //
 ///////////////////////
+wire [7:0] ledsChipset;
 
 `ifndef PITON_CLKS_SIM
 // If these are not provided from
@@ -553,6 +576,38 @@ assign rtc = rtc_div[6];
 assign uart_rts = 1'b0;
 `endif // VCU118_BOARD
 
+// System boots when sys_rst_n is low.
+// sys_rst_n <= 0 (allowing boot) when GPIO_SW_E is 0
+// sys_rst_n <= 0 (allowing boot) when inhibitBootN_q is 1
+// sys_rst_n <= 1 (preventing boot) when inhibitBootN_q is 0 or GPIO_SW_E is 1
+wire clk_48MHz;
+reg inhibitBootN_q;
+wire sys_rst_n = !inhibitBootN_q || GPIO_SW_E;
+
+wire rst;
+fpgaReset u_rst (
+  .i_clk        (clk_48MHz),
+  .i_pllLocked  (!GPIO_SW_E),
+  .o_rst        (rst)
+);
+
+// Correlator on separate reset to allow config the multiple boot runs.
+wire corr_rst;
+fpgaReset u_corr_rst (
+  .i_clk        (clk_48MHz),
+  .i_pllLocked  (1'b1),
+  .o_rst        (corr_rst)
+);
+
+always @ (posedge clk_48MHz)
+  if (rst)
+    inhibitBootN_q <= 1'b0;
+  else if (GPIO_SW_C)
+    inhibitBootN_q <= 1'b1;
+  else
+    inhibitBootN_q <= inhibitBootN_q;
+
+
 // Different reset active levels for different boards
 always @ *
 begin
@@ -687,8 +742,27 @@ assign passthru_pll_rst_n = 1'b1;
 // Sub-module Instances //
 //////////////////////////
 
+// Pipeline for probes to prevent messing up floorplan.
+localparam N_PROBE = 3*12 + 1; // <= 64
+wire tile_clk;
+wire [N_PROBE-2:0] chip_o_probe;
+reg [N_PROBE-1:0] chip_o_probe_q0,
+               chip_o_probe_q1,
+               chip_o_probe_q2,
+               chip_o_probe_q3,
+               chip_o_probe_q;
+always @ (posedge tile_clk) begin
+  chip_o_probe_q0 <= {chip_o_probe, 1'b0};
+  chip_o_probe_q1 <= chip_o_probe_q0;
+  chip_o_probe_q2 <= chip_o_probe_q1;
+  chip_o_probe_q3 <= chip_o_probe_q2;
+  chip_o_probe_q  <= chip_o_probe_q3;
+end
+
 // Piton chip
 chip chip(
+    .o_clk_muxed(tile_clk),
+    .o_probe(chip_o_probe),
     // I/O settings
 `ifdef PITON_FPGA_SYNTH
     // Tie these off if not used
@@ -911,11 +985,12 @@ passthru passthru(
 
 // Piton chipset
 chipset chipset(
+    .corr_clk(clk_48MHz),
     // Only need oscillator clock if
     // chipset is generating its own clocks
 `ifdef F1_BOARD
     .sys_clk(sys_clk),
-`else 
+`else
 
 `ifdef PITON_CHIPSET_CLKS_GEN
 `ifdef PITON_CHIPSET_DIFF_CLK
@@ -1192,7 +1267,7 @@ chipset chipset(
 `ifndef XUPP3R_BOARD
     .sw(sw),
 `endif
-    .leds(leds)
+    .leds(ledsChipset)
 
 `ifdef PITON_ARIANE
     ,
@@ -1218,4 +1293,122 @@ chipset chipset(
 
 );
 
+// {{{ correlator
+wire o_pin_usbpu = !corr_rst;
+wire b_pin_usb_p;
+wire b_pin_usb_n;
+wire o_pin_usb_oe;
+  localparam N_ENGINE = 8;
+
+  assign FMC1_HPC_LA29_N = o_pin_usb_oe;
+  assign b_pin_usb_p = FMC1_HPC_LA28_N;
+  assign b_pin_usb_n = FMC1_HPC_LA29_P;
+  assign FMC1_HPC_LA28_P = o_pin_usbpu;
+
+  wire [N_ENGINE-1:0] o_pin_pwm;
+  assign {
+    FMC1_HPC_LA23_N,
+    FMC1_HPC_LA23_P,
+    FMC1_HPC_LA22_N,
+    FMC1_HPC_LA22_P,
+    FMC1_HPC_LA21_N,
+    FMC1_HPC_LA21_P,
+    FMC1_HPC_LA20_N,
+    FMC1_HPC_LA20_P
+  } = o_pin_pwm;
+
+wire usb_p;
+wire usb_n;
+wire usbOutputEnable; // Select GPIO input/output mode.
+wire usbTx_p;
+wire usbTx_n;
+wire usbRx_p;
+wire usbRx_n;
+
+// Supply receiver with J line state when transmitting.
+assign usbRx_p = usbOutputEnable ? 1'b1 : usb_p;
+assign usbRx_n = usbOutputEnable ? 1'b0 : usb_n;
+
+IOBUF #(
+  .DRIVE        (16),
+  .IBUF_LOW_PWR ("FALSE"),
+  .IOSTANDARD   ("DEFAULT"),
+  .SLEW         ("FAST")
+) iobuf_usbp (
+  .O  (usb_p),
+  .I  (usbTx_p),
+  .IO (b_pin_usb_p),
+  .T  (!usbOutputEnable)
+);
+
+IOBUF #(
+  .DRIVE        (16),
+  .IBUF_LOW_PWR ("FALSE"),
+  .IOSTANDARD   ("DEFAULT"),
+  .SLEW         ("FAST")
+) iobuf_usbn (
+  .O  (usb_n),
+  .I  (usbTx_n),
+  .IO (b_pin_usb_n),
+  .T  (!usbOutputEnable)
+);
+
+wire ledSrc;
+syncBit #(
+  .DEBOUNCE_CYCLES (240000), // 5ms at 48MHz
+  .EDGECNTR_W (1),
+  .N_SYNC     (2)
+) u_btnW (
+  .i_clk        (clk_48MHz),
+  .i_cg         (1'b1),
+  .i_rst        (corr_rst),
+
+  .i_bit      (GPIO_SW_W),
+
+  .o_bit      (),
+  .o_edge     (),
+  .o_rise     (),
+  .o_fall     (),
+  .o_nEdge    (),
+  .o_nRise    (ledSrc),
+  .o_nFall    ()
+);
+
+assign leds = ledSrc ? resultPwm : ledsChipset;
+
+
+wire [N_ENGINE-1:0] resultPwm;
+usbfsBpCorrelator #(
+  .USBFS_VIDPID_SQUAT     (1),
+  .USBFS_ACM_NOT_GENERIC  (1),
+  .USBFS_MAX_PKT          (16), // in {8,16,32,64}. wMaxPacketSize
+  .N_PROBE                (N_PROBE),
+  .N_ENGINE               (N_ENGINE),
+  .MAX_WINDOW_LENGTH_EXP  (16),
+  .MAX_SAMPLE_PERIOD_EXP  (15),
+  .MAX_SAMPLE_JITTER_EXP  (8),
+  .WINDOW_PRECISION       (8), // 1 < p <= MAX_WINDOW_LENGTH_EXP
+  .METRIC_PRECISION       (16),
+  .PKTFIFO_DEPTH          (50)
+) u_usbfsBpCorrelator (
+  .i_clk_48MHz        (clk_48MHz),
+  .i_rst              (corr_rst),
+  .i_cg               (1'b1),
+
+  // USB {d+, d-}, output enable.
+  .i_dp               (usbRx_p),
+  .i_dn               (usbRx_n),
+  .o_dp               (usbTx_p),
+  .o_dn               (usbTx_n),
+  .o_oe               (usbOutputEnable),
+
+  .i_probe            (chip_o_probe_q),
+
+  .o_pwm              (resultPwm)
+);
+assign o_pin_usb_oe = usbOutputEnable;
+
+assign o_pin_pwm = resultPwm;
+// }}} correlator
+
 endmodule
